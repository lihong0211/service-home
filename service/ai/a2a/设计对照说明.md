# A2A 方案设计对照说明

本文档说明 `service/ai/a2a/` 中的每一个文件、类型、接口与 A2A 协议标准规范的对应关系。

---

## 一、总体架构映射

A2A 协议定义了两类角色：

| 协议角色 | 本方案对应 | 说明 |
|---------|-----------|------|
| **Client Agent（客户端智能体）** | `orchestrator.py` | 负责与用户交互，驱动整条链，把任务分发给远程 Agent |
| **Remote Agent（远程智能体）** | `agents/outline_agent.py` / `agents/doc_agent.py` / `agents/summary_agent.py` | 各司其职，暴露标准 A2A 接口，执行具体生成任务 |

协议要求两者之间通过 **HTTP + JSON** 通信，本方案完全遵循。

---

## 二、核心概念与代码对应

### 2.1 智能体名片（Agent Card）

> 协议定义：每个 Agent 在 `/.well-known/agent.json` 暴露一份 JSON"简历"，描述名称、功能、技能、地址、认证方式、能力声明。

**本方案实现：`schemas.py` + 每个 Agent 的 `AGENT_CARD`**

```python
# schemas.py
class AgentCard(BaseModel):
    name: str                          # 智能体名称
    description: str | None           # 功能描述
    url: str                           # 智能体网络地址
    version: str                       # 版本号
    skills: list[AgentSkill]           # 技能列表（协议要求）
    capabilities: AgentCapabilities   # 能力声明（streaming / pushNotifications）
    authentication: dict | None        # 认证方式

class AgentSkill(BaseModel):
    id: str                            # 技能唯一ID
    name: str
    description: str | None
    inputModes: list[str]              # 支持的输入类型（text / data / file）
    outputModes: list[str]             # 支持的输出类型
    examples: list[str] | None        # 示例提示语
```

```python
# agents/outline_agent.py
AGENT_CARD = AgentCard(
    name="OutlineAgent",
    url="http://127.0.0.1:8001",
    skills=[AgentSkill(id="generate_outline", inputModes=["text"], outputModes=["data"])],
    capabilities=AgentCapabilities(streaming=True),
    authentication={"schemes": ["apiKey"]},
)

@app.get("/.well-known/agent.json")   # ← 标准发现端点
async def get_agent_card():
    return AGENT_CARD.model_dump()
```

**对应关系**：

| 协议字段 | 本方案字段 | 实现位置 |
|---------|-----------|---------|
| `name` | `AgentCard.name` | schemas.py + 各 agent |
| `url` | `AgentCard.url` | 各 agent 的 `_BASE_URL` |
| `skills` | `AgentCard.skills[AgentSkill]` | schemas.py |
| `capabilities.streaming` | `AgentCapabilities.streaming=True` | schemas.py |
| `authentication` | `AgentCard.authentication` | 各 agent |
| 发现端点 | `GET /.well-known/agent.json` | 各 agent 的 FastAPI 路由 |

---

### 2.2 任务（Task）与生命周期

> 协议定义：任务是核心工作单元，有唯一 ID，生命周期：`submitted → working → input-required → completed / failed / canceled`。

**本方案实现：`schemas.py` 中的 `Task` / `TaskStatus`**

```python
# schemas.py
TaskState = Literal["submitted", "working", "input-required", "completed", "failed", "canceled"]

class TaskStatus(BaseModel):
    state: TaskState                  # 当前状态
    message: Message | None           # 状态附带的 Agent 回复消息
    timestamp: str                    # 状态变更时间

class Task(BaseModel):
    id: str                           # 唯一任务 ID（uuid）
    contextId: str                    # 上下文 ID（跨 Agent 链共享）
    status: TaskStatus                # 当前状态快照
    artifacts: list[A2AArtifact]      # 任务输出的工件列表
    history: list[Message]            # 完整消息历史（含 user + agent 消息）
```

**生命周期在各 Agent 中的完整走法：**

```
submitted  ←  _process() 开始
working    ←  开始处理输入
completed  ←  生成 artifact 并返回
failed     ←  输入缺失或异常时
```

`_tasks: dict[str, Task]` 是各 Agent 的内存任务存储，支持 `GET /tasks/{task_id}` 轮询查询，满足协议对「长时运行任务」的要求。

---

### 2.3 消息（Message）与零件（Part）

> 协议定义：消息是 Agent 间交流的基本单元，有明确的 `role`（user / agent），内部由零件（Part）组成；零件可以是文本、文件或结构化数据。

**本方案实现：`schemas.py` 中的 `Message` / `TextPart` / `DataPart` / `FilePart`**

```python
# schemas.py
class TextPart(BaseModel):         # 文本零件
    type: Literal["text"] = "text"
    text: str

class DataPart(BaseModel):         # 结构化数据零件（JSON）
    type: Literal["data"] = "data"
    data: dict[str, Any]

class FilePart(BaseModel):         # 文件零件（base64 或 URI）
    type: Literal["file"] = "file"
    file: dict[str, Any]

Part = Union[TextPart, FilePart, DataPart]

class Message(BaseModel):
    role: Literal["user", "agent"] # 明确角色（协议要求）
    parts: list[Part]              # 零件列表（协议要求）
    messageId: str                 # 消息唯一 ID
    taskId: str | None             # 关联任务 ID
    contextId: str | None          # 上下文 ID（跨 Agent 链共享）
```

**编排器构造 Message 的实际示例：**

```python
# orchestrator.py — Step 1：文本消息发给 OutlineAgent
msg = Message(
    role="user",
    parts=[TextPart(text=topic)],     # TextPart：用户需求
    contextId=ctx_id,
)

# orchestrator.py — Step 2：把上一步的 Artifact 数据封为 DataPart 传给 DocAgent
msg = Message(
    role="user",
    parts=[
        TextPart(text="请根据以下大纲生成文章正文"),
        DataPart(data=outline_data),  # DataPart：结构化工件数据
    ],
    contextId=ctx_id,
)
```

---

### 2.4 工件（Artifact）

> 协议定义：Artifact 是 Agent 执行任务的具体输出（文档、图片、结构化数据），由 `parts[]` 组成，支持流式分块（`lastChunk`、`append`）。

**本方案实现：`schemas.py` 中的 `A2AArtifact`**

```python
# schemas.py
class A2AArtifact(BaseModel):
    artifactId: str                # 工件唯一 ID
    name: str | None               # 工件名（如 "outline"、"document"）
    description: str | None
    parts: list[Part]              # 工件内容，由零件组成（协议核心）
    index: int = 0                 # 分块索引（流式输出时使用）
    append: bool | None            # 是否追加（流式输出时使用）
    lastChunk: bool | None         # 是否最后一块（流式输出时使用）
```

**各 Agent 生成 Artifact 的示例：**

```python
# agents/outline_agent.py
artifact = A2AArtifact(
    name="outline",
    parts=[DataPart(data=outline_dict)],  # 工件内容用 DataPart 承载
    lastChunk=True,
)
task.artifacts = [artifact]
```

**编排器提取 Artifact 数据：**

```python
# orchestrator.py
def _extract_data_from_task(task: Task) -> dict | None:
    for artifact in task.artifacts:
        for part in artifact.parts:
            if part.type == "data":
                return part.data          # 取出 DataPart 的结构化数据
```

---

## 三、标准工作流程对应

> 协议定义的典型流程：能力发现 → 发起任务 → 任务执行 → 任务完成

### 3.1 能力发现

```python
# orchestrator.py
def _discover(agent_name: str) -> dict:
    r = requests.get(f"{base}/.well-known/agent.json", timeout=5)
    return r.json()

# run_chain 中每步都先发现
_discover("OutlineAgent")
```

编排器在发起每步任务前，先 `GET /.well-known/agent.json` 验证 Agent 在线并读取其能力。

---

### 3.2 发起任务（SendMessage）

```python
# orchestrator.py
def _send_message(agent_name: str, message: Message) -> Task:
    req = SendMessageRequest(message=message)       # 标准请求体
    r = requests.post(f"{base}/tasks/send", json=req.model_dump())
    return Task(**r.json())                         # 返回完整 Task
```

请求体固定为 `{"message": {...}}`，完全符合协议的 `SendMessage` 请求格式。

---

### 3.3 任务执行与进度（SSE）

同步方式（`POST /tasks/send`）：Agent 处理完成后一次性返回 Task。

流式方式（`POST /tasks/sendSubscribe`）：Agent 通过 SSE 分步推送：

```
data: {"task": {"status": {"state": "submitted"}, ...}}
data: {"task": {"status": {"state": "working"}, ...}}
data: {"taskId": "...", "artifact": {"parts": [{"type": "data", ...}]}}   ← TaskArtifactUpdateEvent
data: {"task": {"status": {"state": "completed"}, ...}}
```

对应 schemas.py 中的两个 SSE 事件类型：

```python
class TaskStatusUpdateEvent(BaseModel):      # 状态变更事件
    task: Task

class TaskArtifactUpdateEvent(BaseModel):    # 工件推送事件
    taskId: str
    contextId: str
    artifact: A2AArtifact
```

---

### 3.4 任务查询（轮询）

```python
# orchestrator.py
def _poll_task(agent_name: str, task_id: str) -> Task:
    r = requests.get(f"{base}/tasks/{task_id}", timeout=10)
    return Task(**r.json())
```

各 Agent 实现 `GET /tasks/{task_id}`，将 Task 存入内存（`_tasks` 字典），供编排器或外部客户端轮询查询状态。

---

## 四、接口与协议规范映射表

| 协议规范 | HTTP 方法 + 路径 | 本方案实现文件 |
|---------|----------------|--------------|
| 能力发现 | `GET /.well-known/agent.json` | 各 agent 的 `@app.get("/.well-known/agent.json")` |
| SendMessage（同步） | `POST /tasks/send` | 各 agent 的 `tasks_send()` |
| 任务状态查询 | `GET /tasks/{task_id}` | 各 agent 的 `get_task()` |
| SendMessage（SSE流式） | `POST /tasks/sendSubscribe` | 各 agent 的 `tasks_send_subscribe()` |
| 客户端 SendMessage 调用 | — | `orchestrator.py` 的 `_send_message()` |
| 客户端能力发现调用 | — | `orchestrator.py` 的 `_discover()` |

---

## 五、contextId：跨 Agent 链的上下文追踪

协议要求同一会话的消息和任务共享 `contextId`，用于追踪整条协作链。

```python
# orchestrator.py
ctx_id = str(uuid.uuid4())    # 整条链生成一次，所有 Message 共用

msg = Message(role="user", parts=[...], contextId=ctx_id)   # Step 1
msg = Message(role="user", parts=[...], contextId=ctx_id)   # Step 2
msg = Message(role="user", parts=[...], contextId=ctx_id)   # Step 3
```

各 Agent 把 `contextId` 写入 Task 和 Message，前端可通过它把三步关联为同一次生成请求。

---

## 六、目录结构与职责

```
service/ai/a2a/
├── schemas.py               # A2A 标准类型（Part / Message / Task / Artifact / AgentCard）
├── orchestrator.py          # Client Agent：能力发现 + SendMessage + 链式编排
├── __init__.py              # 对外导出 get_result_for_frontend，路由层调用入口
├── run_orchestrator_api.py  # 独立编排器 HTTP 服务（可选，8010）
└── agents/
    ├── outline_agent.py     # Remote Agent（8001）：主题 → 大纲
    ├── doc_agent.py         # Remote Agent（8002）：大纲 → 正文
    └── summary_agent.py     # Remote Agent（8003）：正文 → 摘要
```

---

## 七、未实现项（已知差距）

| 标准功能 | 状态 | 说明 |
|---------|------|------|
| `input-required` 任务状态 | 未实现 | Agent 需要补充信息时暂停等待，当前三个 Agent 不涉及多轮补充 |
| Agent 认证校验 | 仅声明 | `authentication.schemes=["apiKey"]` 已在 AgentCard 中声明，但路由层尚未真正校验请求头中的 Key |
| `tasks/cancel` 取消任务 | 未实现 | 当前任务都是短时同步任务，未来长时任务可扩展 |
| 推送通知（pushNotifications） | 未实现 | `capabilities.pushNotifications=false`，已如实声明 |
| 集中式 Agent 注册/发现 | 未实现 | 当前 URL 硬编码在 `orchestrator.AGENT_URLS`，生产环境可接入注册中心 |
